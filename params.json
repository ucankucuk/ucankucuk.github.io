{
  "name": "| JAVA |",
  "tagline": "Blog",
  "body": "#Java Collections(Java Koleksiyonları)\r\n\r\nJava koleksiyonları : Java’da bir koleksiyon (collection - bazen container, ambar diye adlandırılır) nesnelerden olusan bir\r\ntopluluğu bir arada tutan bir yapıdır.Yazılım geliştirirken bazen tek bir değişken içerisinde birden fazla eleman tutmak isteyebiliriz.Bunun gibi durumlarda Java'nın `Collection` sınıfını kullanırız.Bu sınıf : **veri depolama**  ,depolanan veriyi **çekme** , veriyi  **işlemek** ve depolanan veriler içerisinde veri **aramak** gibi işlemler için kullanılır.Bu sınıflar içerisinden depolanan veri **sıralı** veya **sırasız** olabilir.Ayrıca aynı öğe bazı koleksiyonlarda **birden çok kez** **bulunabilir**, bazılarında **bulunamaz**.\r\n\r\nJava koleksiyonlarının avantajları olduğu gibi dezavantajları da vardır.\r\n* **Avantajları**:\r\n  - Verileri tek bir değişkende toplamamızı ve bu toplanan verilerin işlenmesinde kolaylık sağlar.\r\n  - Yazılımcı , koleksiyon sınıf içerisinde ki algoritmaları kullanarak yeni algoritma yazmak zorunda kalmaz.Bu sayede yazılım kolay anlaşılabilir ve tekrar kullanılabilir **(software reuse)** olmasını sağlar.\r\n  - Yazılımcıya performans kaybı yaşatmadan hatta performansı arttıran kullanışlı algoritma ve veri yapıları sağlar.\r\n  - Belli bir boyutları yoktur.İçerisine veri ekleyip çıkardıkça boyutları değişir.\r\n  - Bu özelliği ile Arrays sınıfından öne geçer.Çünkü Java'da diziler önceden boyutlandırılır. Boyutundan fazla eleman eklememize olanak yoktur.\r\n* **Dezavantajları** : \r\n  - Koleksiyonlara veri eklerken ; koleksiyonun veri tipine göre veri ekleyebiliriz.\r\n  - Derleme anında veri tipi denetimi yapılmaz.\r\n\r\n##Collections Interface (Koleksiyon Arayüzü)\r\n`Collection` arayüzü koleksiyon arabirimleri içerisinde bulunan bu arayüz hiyerarşik olarak en tepede bulunan birimdir.**Java.util** paketi içerisinde bulunan bu arayüz , bize birkaç arayüz ve bunlar altında bulunan sınıfları sunar.\r\n\r\n![Hiyerarşik Düzen](http://2.bp.blogspot.com/-wHhWy9drvRg/UBDARrz-LGI/AAAAAAAAAD4/j2M-W98FaZ0/s1600/java-collection.jpg)\r\n\r\n - **Collection** : Collection interface'inin hiyerarşik olarak en tepesinde bulunan , en genel sınıftır.\r\n - **List** : Liste yapısını örnek alır.İçerisinden bir elemandan birden fazla bulundurmaya izin verir.Elemanları sıralı biçimde tutar.\r\n - **Set** : İçinde saklanan elemanlar **sırarız** biçimde tutulur. İçerisinden bir elemandan birden fazla bulundurmaya izin vermez.\r\n - **SortedSet** : Verileri sıralı olarak tutar.İçerisinden bir elemandan birden fazla bulundurmaya izin vermez.\r\n - **Queue** : Kuyruk yapısını benimseyen koleksiyon tipidir. Liste türünden türetilmiştir.Ama indis değerleriyle işlem yapmaz.Bu öelliğiyle liste türünden ayrılır.\r\n - **Map** Elemanlarla bunlara karşılık verilen anahtar değerleriyle eşleştiren arayüzdür . Tekrar eden bir anahtar bulundurmaz. Grafikten de görüleceği gibi Map farklı yerde gösterilmiştir. Map arayüzü koleksiyon arayüzü ile benzerlik gösterir.Ancak Map arayüzünün elemanlarının her birini Unique bir anahtar değeriyle saklaması onu koleksiyonlardan ayırır.\r\n - **SortedMap** :Map arayüzünün özelliklerin taşır.Map'ten farkı anahtar değerleri artan bir sırada saklanır.\r\n\r\n**Koleksiyon sınıfları ortak olarak birtakım metodlar kullanır.Metodlar bazı sınıflarda farklılık gösterebilir ama genel olarak aynıdır.\r\n - **add()** : Koleksiyon nesnesine referans verilen elemanı ekler.\r\n - **remove()** : Koleksiyon nesnesine referans verilen elemanı siler.\r\n - **size()** : Koleksiyon nesnesindeki eleman sayısını verir.\r\n - **isEmpty()** : Koleksiyon nesnesinin boş olup olmadığını kontrol eder.Boolean değer döner.\r\n - **contains()** : Koleksiyon nesnesi içerisinden referans olarak belirtilen elemanı arar.Booean değer döner.\r\n - **iterator()** : Koleksiyon nesnesi iterasyon nesnesine referans olarak göndermeye yarar.\r\n\r\n#Iterator\r\n* Iterator() metodu koleksiyon nesnelerini yinelememizi sağlar.\r\n* Iterator : koleksiyon nesnesi altındaki elemanlar arasında başlangıçtan sonuna kadar tek tek geçiş yapmamızı, elemanları güvenle silmemizi sağlar.\r\n* Iterator arayüzünün metodlar:\r\n - **hasNext** : Koleksiyon nesnesinin bir sonraki elemanının var olup olmadığını kontrol eder.Bir sonraki eleman varsa **true** yoksa **false** döner.\r\n - **next** : Koleksiyon nesnesinin bir sonraki elemana ulaşmasını sağlar.\r\n\r\n#SET(KÜMELER)\r\n\r\n* Collection interface'ini extends eder.(Miras alır).\r\n* Verileri sıralı bir şekilde tutmaz ayrıca bir elemandan sadece bir tane bulunur.\r\n* Set arayüzünü öğesi **HashSet**'tir.\r\n\r\n##HashSet\r\n* Set koleksiyonun bir örneğidir.Elemanların sıralı olması şartı yoktur.(Bu nedenle erişim sırası belirsizdir.)\r\n* Tekrarlı eleman içermez.\r\n* HashSet Kullanımına bir örnek:\r\n\r\n~~~~java\r\npackage ucankucuk.github.io;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\n\r\npublic class HashSetExample {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tHashSet<String> hashSet = new HashSet<String>(); // HashSet koleksiyonu\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// oluşturuldu.\r\n\r\n\t\t// HashSet nesnesine elemanlar eklendi.\r\n\t\thashSet.add(\"Ali\");\r\n\t\thashSet.add(\"Mehmet\");\r\n\t\thashSet.add(\"Ahmet\");\r\n\t\thashSet.add(\"Veli\");\r\n\t\thashSet.add(\"Ali\"); // Aynı eleman bir daha eklendi.\r\n\t\thashSet.add(null);\r\n\r\n\t\tSystem.out.println(hashSet);\r\n\r\n\t\t// For döngüsüyle kullanım örneği\r\n\t\tfor (String isim : hashSet) {\r\n\t\t\tSystem.out.println(isim);\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n* Programın çıktısı :\r\n - [null, Ahmet, Veli, Mehmet, Ali]\r\n - null\r\n - Ahmet\r\n - Veli\r\n - Mehmet\r\n - Ali\r\n - [Ahmet, Veli, Mehmet, Ali]\r\n* Örnekte görüldüğü gibi aynı eleman hashset'e eklendiğinde önceki elemanı ezer ve hashset'te bir tane bulunur.\r\n* **remove() metodu belirtilen eleman varsada yoksada **çalışır**.Varsa siler yoksa false değeri döndürür.\r\n* Aynı elemanın tekrar eklemeye çalışılması erişim sırasını etkilemez.\r\n\r\n##LinkedHashSet\r\n\r\n* HashSet ile benzerlik gösterir.Farklı yanı : HashSet'te öğelere erişim sırası belirsizdi.LinkedHashSet'te ise öğeler birbirine **çift yönlü** bağlıdır.\r\n* Elemanlar artan sırada sıralı değil giriş sırasına göre sıralıdır.\r\n* Tekrarlı eleman bulunmaz.\r\n* LinkedHashSet örneği : \r\n\r\n~~~~java\r\npackage ucankucuk.github.io;\r\n\r\nimport java.util.*;\r\n\r\npublic class LinkedHashSetExample {\r\n\r\n\tpublic static void main(String args[]) {\r\n\t\t// create a hash set\r\n\t\tLinkedHashSet<String> hs = new LinkedHashSet<String>();\r\n\t\t// add elements to the hash set\r\n\t\ths.add(\"B\");\r\n\t\ths.add(\"A\");\r\n\t\ths.add(\"D\");\r\n\t\ths.add(\"E\");\r\n\t\ths.add(\"C\");\r\n\t\ths.add(\"F\");\r\n\t\tSystem.out.println(hs);\r\n\t}\r\n}\r\n~~~~\r\n* Ekran çıktısı :\r\n - [B, A, D, E, C, F]\r\n\r\n##SortedSet\r\n\r\n* Set koleksiyonun alt arayüzüdür.\r\n* HashSet ile benzerdir.Farklı yanı : elemanların sıralı tutulmasıdır.Bu arayüzün kullanılan öğesi **TreeSet**'tir.\r\n\r\n##TreeSet\r\n\r\n* SortedSet arayüzünün alt sınıfıdır.\r\n* HashSet ile aynı metodları kullanır.\r\n* Tip kontrolü yapılır.Yani TreeSet'e içerisindeki elemanların tipinden farklı bir tipte eleman eklemeye çalışırsak **derleme anında hata verecektir.**\r\n* TreeSet örnekleri:\r\n\r\n~~~~java\r\npackage ucankucuk.github.io;\r\n\r\nimport java.util.TreeSet;\r\n\r\npublic class TreeSetExample {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tTreeSet<String> treeSet = new TreeSet<String>();\r\n\t\ttreeSet.add(\"istanbul\");\r\n\t\ttreeSet.add(\"ankara\");\r\n\t\ttreeSet.add(\"izmir\");\r\n\r\n\t\tSystem.out.println(treeSet);\r\n\t}\r\n\r\n}\r\n~~~~\r\n\r\n* Ekran çıktısı:\r\n - [ankara, istanbul, izmir]\r\n\r\n~~~~java\r\npackage ucankucuk.github.io;\r\n\r\nimport java.util.TreeSet;\r\n\r\npublic class TreeSetExample {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tTreeSet<Integer> treeSet = new TreeSet<Integer>();\r\n\t\ttreeSet.add(34);\r\n\t\ttreeSet.add(35);\r\n\t\ttreeSet.add(06);\r\n\r\n\t\tSystem.out.println(treeSet);\r\n\t}\r\n\r\n}\r\n~~~~\r\n* Ekran çıktısı :\r\n - [6, 34, 35]\r\n\r\n* **TreeSet HashSet'ten farklı olarak aşağıdaki metodları içerir.**\r\n\r\n|                                    |                                                                   | \r\n|------------------------------------|-------------------------------------------------------------------| \r\n| **first() : Object**               |  Koleksiyon öğesinin 1.elemanını verir.                           | \r\n| **last() : Objest**                |  Koleksiyon öğesinin son elemanını verir.                         | \r\n| **headSet(Object toElement)**      |  Koleksiyon öğesindeki toElement'ten önceki elemanları verir      | \r\n| **subSet(Object ilk Object son)**  |  İlk'den son'a kadar olan elemanları verir(son dahil değil)       | \r\n| **tailSet(Object fromElement)**    |  Koleksiyon öğesindeki fromElement'i ve sonraki elemanları verir. |\r\n\r\n* Metodun kullanımıyla ilgili örnekler:\r\n\r\n~~~~java\r\npackage ucankucuk.github.io;\r\n\r\nimport java.util.TreeSet;\r\n\r\npublic class TreeSetMethods {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tTreeSet<Integer> treeSet = new TreeSet<Integer>();\r\n\t\ttreeSet.add(34);\r\n\t\ttreeSet.add(35);\r\n\t\ttreeSet.add(07);\r\n\t\ttreeSet.add(66);\r\n\t\ttreeSet.add(38);\r\n\t\ttreeSet.add(28);\r\n\r\n\t\tSystem.out.println(treeSet);\r\n\t\tSystem.out.println(treeSet.first());\r\n\t\tSystem.err.println(treeSet.last());\r\n\t\tSystem.out.println(treeSet.subSet(28, 66));\r\n\t\tSystem.out.println(treeSet.tailSet(07));\r\n\r\n\t}\r\n\r\n}\r\n~~~~\r\n* Ekran Çıktıları :\r\n - [7, 28, 34, 35, 38, 66]\r\n - 7\r\n - 66\r\n - [28, 34, 35, 38]\r\n - [7, 28, 34, 35, 38, 66] \r\n\r\n#LIST (Liste Yapıları) \r\n* Verileri bir dizi halinde depolar.\r\n* Dizilerde olduğu gibi burada da elemanların indis değerleri var.İndis değerleri ile elemanlara erişilebilir , arama yapılabilir.\r\n* Liste yapılarını dizilerden ayıran özellik liste yapılarının boyutlarının önceden ayarlanmış olmamasıdır.Bu nedenle daha kullanışlıdır.\r\n* Kopya eleman bulundurmaya izin verir.\r\n\r\n##ArrayList\r\n* Elemanları bir dizi biçiminde saklar ve boyut eleman eklendikçe büyür.\r\n* Elemanlara indeks değerleriyle erişmek ve silmek mümkün.\r\n* **Not** : dizilerden daha avantajlı olmalarına rağmen ; eğer depolanacak veri sayısı belli ve kolay kolay değişmiyorsa ArrayList kullanmak yerine Array kullanmak daha verimli olacaktır.\r\n* ArrayList sınıfı Array'den farklı olarak nesneleri depolayabilir.\r\n* ArrayList kullanımıyla ilgili örnek :\r\n~~~~~java\r\npackage ucankucuk.github.io;\r\n\r\nimport java.util.*;\r\n\r\npublic class ArrayListExample {\r\n\r\n\tpublic static void main(String args[]) {\r\n\t\t// ArrayList oluşturma.\r\n\t\tArrayList<String> list = new ArrayList<String>();\r\n\r\n\t\t// ArrayList nesnesine eleman ekleme.\r\n\t\tlist.add(\"Item1\");\r\n\t\tlist.add(\"Item2\");\r\n\t\tlist.add(2, \"Item3\"); // 2.indise Item3'ü ekledi\r\n\t\tlist.add(\"Item4\");\r\n\r\n\t\tSystem.out.println(\"ArrayList içeriği : \" + list);\r\n\r\n\t\t/*\r\n\t\t * ArrayList nesnesi içerisinde arama yapma. Eğer aranan eleman varsa :\r\n\t\t * metod aranan elemanın indeksini döndürür. Eğer aranan eleman yoksa :\r\n\t\t * metod -1 değeri döndürür.\r\n\t\t */\r\n\t\tint pos = list.indexOf(\"Item2\");\r\n\t\tSystem.out.println(\"Aranan elemanın indeksi : \" + pos);\r\n\r\n\t\t/*\r\n\t\t * ArrayList nesnesinin boş olup olmadığının kontrolü Eğer liste boş\r\n\t\t * değilse false,boşsa true değerinin döndürür.\r\n\t\t */\r\n\t\tboolean check = list.isEmpty();\r\n\t\tSystem.out.println(\"Kontrol sonucu : \" + check);\r\n\r\n\t\t// Listenin uzunluğu\r\n\t\tint size = list.size();\r\n\t\tSystem.out.println(\"Liste uzunluğu : \" + size);\r\n\r\n\t\t/*\r\n\t\t * Listede eleman var mı kontrolü eğer eleman varsa true , yoksa false\r\n\t\t * döndür.\r\n\t\t */\r\n\t\tboolean element = list.contains(\"Item5\");\r\n\t\tSystem.out.println(\"Arama sonucu : \" + element);\r\n\r\n\t\t/*\r\n\t\t * İndeksi verilen elemanı getirme n elemanlı bir dizi de verilen indis\r\n\t\t * 0...(n-1) aralığında değilse; derleme sırasında\r\n\t\t * java.lang.IndexOutOfBoundsException hatası döner.\r\n\t\t */\r\n\t\tString item = list.get(0);\r\n\t\tSystem.out.println(\"Eleman : \" + item);\r\n\r\n\t\t// Elemanları getirmek için aşağıda 3 yol gösterilmiştir.\r\n\t\tSystem.out.println(\"1.Yol : For döngü kullanarak\");\r\n\t\tfor (int i = 0; i < list.size(); i++) {\r\n\t\t\tSystem.out.println(\"Index: \" + i + \" - Item: \" + list.get(i));\r\n\t\t}\r\n\r\n\t\tSystem.out.println(\"2.Yol : ForEach döngü kullanarak\");\r\n\t\tfor (String str : list) {\r\n\t\t\tSystem.out.println(\"Item is: \" + str);\r\n\t\t}\r\n\r\n\t\tSystem.out.println(\"3.Yol : Iterator kullanarak\");\r\n\t\tfor (Iterator<String> it = list.iterator(); it.hasNext();) {\r\n\t\t\tSystem.out.println(\"Item is: \" + it.next());\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Verilen indisdeki elemanı değiştirme. n elemanlı bir dizi de verilen\r\n\t\t * indis 0...(n-1) aralığında değilse; derleme sırasında\r\n\t\t * java.lang.IndexOutOfBoundsException hatası döner.\r\n\t\t */\r\n\t\tlist.set(1, \"NewItem\");\r\n\t\tSystem.out.println(\"Değişimden sonra : \" + list);\r\n\r\n\t\t/*\r\n\t\t * indeksi verilen elemanı silme n elemanlı bir dizi de verilen indis\r\n\t\t * 0...(n-1) aralığında değilse; derleme sırasında\r\n\t\t * java.lang.IndexOutOfBoundsException hatası döner.\r\n\t\t */\r\n\t\tlist.remove(1);\r\n\r\n\t\t/*\r\n\t\t * Verilen elemanı silme. Eğer liste içeriğinde bulunmayan eleman\r\n\t\t * parametre olarak verilirse derleme sırasında hata alacaktır.\r\n\t\t */\r\n\t\tlist.remove(\"Item3\");\r\n\r\n\t\tSystem.out.println(\"Silme işlemlerinden sonra : \" + list);\r\n\r\n\t\t// Array'den ArrayList'e çevirme.\r\n\t\tString[] simpleArray = list.toArray(new String[list.size()]);\r\n\t\tSystem.out.println(\"Array ArrayList'e çevirildikten sonra: \" + Arrays.toString(simpleArray));\r\n\t}\r\n}\r\n~~~~\r\n\r\n* Ekran çıktısı:\r\n - ArrayList içeriği : [Item1, Item2, Item3, Item4]\r\n - Aranan elemanın indeksi : 1\r\n - Kontrol sonucu : false\r\n - Liste uzunluğu : 4\r\n - Arama sonucu : false\r\n - Eleman : Item1\r\n - Retrieving items with loop using index and size list\r\n - Index: 0 - Item: Item1\r\n - Index: 1 - Item: Item2\r\n - Index: 2 - Item: Item3\r\n - Index: 3 - Item: Item4\r\n - Retrieving items using foreach loop\r\n - Item is: Item1\r\n - Item is: Item2\r\n - Item is: Item3\r\n - Item is: Item4\r\n - Retrieving items using iterator\r\n - Item is: Item1\r\n - Item is: Item2\r\n - Item is: Item3\r\n - Item is: Item4\r\n - Değişimden sonra : [Item1, NewItem, Item3, Item4]\r\n - The final contents of the arraylist are: [Item1, Item4]\r\n - The array created after the conversion of our arraylist is: [Item1, Item4]\r\n\r\n##LinkedList (Bağlı Liste)\r\n* List arayüzünü implemente eder.Bundan dolayı List arayüzünün tüm metodlarını kullanabilir.\r\n* List yapısından farklı olarak ilk eklemanı silme , ilk elemanı ekleme , son elemanı silme , sonelemanı ekleme gibi metodlara sahiptir.Bu metodlara sahip olduğundan dolayı isteğe göre, **stack (yığın -LIFO)**, **queue (kuyruk -FIFO)**, **deque (çifte sonlanmış kuyruk)** \r\nyapıları elde edilebilir.\r\n* LinkedList yapısında elemanlar eklenirken aralarından bir bağ konulur. Bu bağ tek yönlü veya çift yönlü olabilir.\r\n* LinkedList metodlarının kullanımıyla ilgili örnek :\r\n\r\n~~~~java\r\nimport java.util.LinkedList;\r\n\r\npublic class LinkedListExample {\r\n    public static void main(String[] args) {\r\n        LinkedList<String> linkedList = new LinkedList<String>();\r\n        linkedList.add(\"istanbul\");\r\n        linkedList.add(\"ankara\");\r\n        linkedList.add(\"izmir\");\r\n        linkedList.add(\"antalya\");\r\n        linkedList.add(\"giresun\");\r\n\r\n        System.out.println(\"LinkedList içeriği : \" + linkedList);\r\n        System.out.println(\"LinkedLis'in ilk elemanı : \" + linkedList.getFirst());\r\n        System.out.println(\"LinkedLis'in son elemanı : \" + linkedList.getLast());\r\n        linkedList.addLast(\"trabzon\");\r\n        System.out.println(\"En sona eleman eklendikten sonra LinkedList içeriği : \" + linkedList);\r\n        linkedList.addFirst(\"giresun\");\r\n        System.out.println(\"En başa eleman eklendikten sonra LinkedList içeriği : \" + linkedList);\r\n        linkedList.removeLast();\r\n        System.out.println(\"Son eleman silindikten sonraki LinkedList içeriği : \" + linkedList);\r\n\r\n    }\r\n\r\n}\r\n~~~~\r\n* Ekran çıktısı :\r\n - LinkedList içeriği : [istanbul, ankara, izmir, antalya, giresun]\r\n - LinkedLis'in ilk elemanı : istanbul\r\n - LinkedLis'in son elemanı : giresun\r\n - En sona eleman eklendikten sonra LinkedList içeriği : [istanbul, ankara, izmir, antalya, giresun, trabzon]\r\n - En başa eleman eklendikten sonra LinkedList içeriği : [giresun, istanbul, ankara, izmir, antalya, giresun, trabzon]\r\n - Son eleman silindikten sonraki LinkedList içeriği : [giresun, istanbul, ankara, izmir, antalya, giresun]\r\n\r\n* **Queue (Kuyruk)** : İlk giren çıkar mantığını benimseyen yapıdır. Elemanlar listeye sondan eklenir,silme işlemi listenin başından yapılır.\r\n\r\n~~~~java\r\npackage ucankucuk.github.io;\r\nimport java.util.LinkedList;\r\n\r\n\r\npublic class Queue {\r\n    LinkedList<String> linkedList = new LinkedList<String>();\r\n    \r\n    public void addElement(String element){\r\n        linkedList.addLast(element);\r\n    }\r\n    public void removeElement(String element){\r\n        linkedList.removeFirst();\r\n    }\r\n    public String getElement(){\r\n        return linkedList.getFirst();\r\n    }\r\n    public boolean isEmpty(){\r\n        return linkedList.isEmpty();\r\n    }\r\n    \r\n}\r\n~~~~\r\n\r\n* **Stack (Yığıt-Yığın)** : Kuyruk yapısının tam tersi mantık vardır. Elemanlar daima listenin sonuna eklenir ve silme işlemi yığıtın sonundan yapılır.\r\n\r\n~~~~~java\r\npackage ucankucuk.github.io;\r\n\r\nimport java.util.LinkedList;\r\n\r\npublic class Stack {\r\n   LinkedList<String> linkedList = new LinkedList<String>();\r\n   \r\n   public void addElementStack(String element){\r\n       linkedList.addFirst(element);\r\n   }\r\n   public void firstElementStack(String element){\r\n       linkedList.getFirst();\r\n   }\r\n   public void removeElementStack(String element){\r\n       linkedList.removeFirst();\r\n   }\r\n   public boolean isEmpty(){\r\n       return linkedList.isEmpty();\r\n   }\r\n}\r\n~~~~\r\n\r\n##Vector (Vektör)\r\n\r\n* Array sınıfının boyutu sabit olduğu için bu yazılım geliştirme sırasında dezavantajlara sebep oldu.Bu nedenle Java 2 ile birlikte ArrayList ve Vector sınıfı getirildi.ArrayList sınıfı senkronize değildir ama Vector sınıfından daha hızlıdır. Vector sınıfı ise senkronizedir ama ArrayList'ten daha yavaştır.Bu nedenle multi-thread (çoklu işlem)'lerde Vector sınıfını kullanmak multi-thread ortamda güvenilirliği arttırır.\r\n* Vector sınıfı Java 2 ile birlikte ArrayList'in birçok metodunu aldığı için Vector sınıfı Array sınıfının önüne geçmiştir.\r\n* Aslında vektörler içine eleman ekledikçe büyüyen dizilerdir.Ayrıca vektörlerin kapasitesinin ne değerde artacağı uygulamada tarafından belirlenebilir.\r\n* Bazı vektör metodları:\r\n  - **Vector v = new  Vector();**\r\ndeyimi  uzunluğu 10 olan boş bir vektör yaratır. Uzunluk belirtilmediği zaman, vektör sınıfının öntanımlı (default) uzunluğu daima 10 bileşendir. \r\n  - **Vector v = new Vector(50);** Uzunluğu 50 olan bir vektör nesnesi yaratır.\r\n\r\n  - **Vector v = new  Vector(Collection c);**\r\ndeyimi belirtilen koleksiyonun öğelerini içeren bir vektör yaratır.\r\n\r\n  - **Vector v = new  Vector(int  başlangıçKapasitesi);**\r\ndeyimi, başlangıç kapasitesi belirlenen boş bir vektör yaratır. Standart kapasite artışı 0 dır.\r\n\r\n  - **Vector v = new  Vector(int  başlangıçKapasite,  int  kapasiteArtışı);**\r\ndeyimi, başlangıç kapasitesi belirlenen boş bir vektör yaratır. Kapasite artışı kapasiteArtışı ile verilen int değerdir.\r\n * Vektör örneği :\r\n~~~~java\r\npackage ucankucuk.github.io;\r\n\r\nimport java.util.Vector;\r\n\r\npublic class VectorExample {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Vector<String> v = new Vector<String>(); //Vektör oluşturma.\r\n\r\n        /*\r\n         * Vektöre eleman ekleme\r\n         * Kopya eleman eklenebilir\r\n         */\r\n        v.add(\"Giresun\");\r\n        v.add(\"İzmir\");\r\n        v.add(\"İstanbul\");\r\n        v.add(\"Ankara\");\r\n        v.add(\"Antalya\");\r\n        v.add(\"Giresun\");\r\n\r\n        //Vektörden eleman silme\r\n        v.remove(5);\r\n\r\n        System.out.println(\"Eklemelerden sonra vektörün son hali : \" + v);\r\n\r\n        // verilen indekse eleman ekleme\r\n        v.add(3, \"Afyon\");\r\n        // vektör uzunluğu\r\n        System.out.println(\"Vektörün uzunluğu : \" + v.size());\r\n\r\n        // Vektörün öğelerini listeleme (ForEach ile)\r\n        for (String eleman : v) {\r\n            System.out.println(eleman);\r\n        }\r\n        //Vektörün öğelerini listeleme (For ile)\r\n        for (int i = 0; i < v.size(); i++) {\r\n            System.out.println(\"Vektör öğesi : \" + i + \" :\" + v.get(i));\r\n        }\r\n    }\r\n}\r\n~~~~\r\n\r\nEkran Çıktısı :\r\n  - Eklemelerden sonra vektörün son hali : [Giresun, İzmir, İstanbul, Ankara, Antalya]\r\n  - Vektörün uzunluğu : 6\r\n  - Giresun\r\n  - İzmir\r\n  - İstanbul\r\n  - Afyon\r\n  - Ankara\r\n  - Antalya\r\n  - Vektör öğesi : 0 :Giresun\r\n  - Vektör öğesi : 1 :İzmir\r\n  - Vektör öğesi : 2 :İstanbul\r\n  - Vektör öğesi : 3 :Afyon\r\n  - Vektör öğesi : 4 :Ankara\r\n  - Vektör öğesi : 5 :Antalya\r\n\r\n#MAP\r\n\r\n\r\n#Java StringBuilder & StringBuffer\r\n\r\n* StringBuilder nesneleri değiştirilebilir olması haricinde String nesnelerine benzer.\r\n* StringBuilder karakter dizisi içeren değişken uzunlukta ki diziler gibi davranır.\r\n* Herhangi bir noktada metod çağırımıyla uzunluk ve dizi içeriği değiştirilebilir.\r\n* Örneğin StringBuilder nesnelerinde **append() , insert(), reverse() , replace()** metodları vardır.\r\n* Çok sayıda dizileri bağlamada , StringBuilder nesnelerini kullanmak daha verimlidir.\r\n\r\n#Length & Capacity \r\n\r\n* StingBuilder sınıfı length() metoduna sahiptir.Bu özelliğiyle String sınıfına benzerdir.Ayrıca StringBuilder'ın **capacity()** metodu vardır.Bu metod StringBuilder'ın kapasitesini geri döndürür.Bu özellik String sınıfında yoktur.\r\n\r\n| Yapıcı(Constructor)                 | Açıklama                                                      | \r\n|-------------------------------------|---------------------------------------------------------------| \r\n| **StringBuilder()**                 | Boş bir StringBuilder oluşturur(Kapasitesi : 16)              | \r\n| **StringBuilder(CharSequence cs)**  | CharSequence içeriğinin aynısını 16 boş elemanlı haliyle bir  | \r\n|                                     |StringBuilder oluştururur.                                     | \r\n| **StringBuilder(int initCapacity)** | initCapacity uzunluğu kadar kapasiteli bir StringBuilder      | \r\n|                                     | oluşturur.                                                    | \r\n\r\n~~~~java\r\npackage ucankucuk.github.io;\r\n\r\npublic class CapacityOfStringBuilder {\r\n\r\n    public static void main(String[] args) {\r\n        StringBuilder sb = new StringBuilder();//16 Kapasiteli StringBuilder oluşturduk.\r\n        sb.append(\"Greetings\");//9 karakterlik bir String ekledik.\r\n    }\r\n\r\n}\r\n~~~~\r\n* StringBuilder'ın durumu:\r\n* ![ucankucuk.github.io](https://docs.oracle.com/javase/tutorial/figures/java/objects-stringBuffer.gif \"ucankucuk.github.io\")\r\n* StringBuilder sınıfının String sınıfından farklı bazı metodları vardır.Bunlar:\r\n\r\n| Metod                                    | Açıklama                                                | \r\n|------------------------------------------|---------------------------------------------------------| \r\n| **void setLength(int newLength)**        | Karakter dizisinin uzunluğunu ayarlar.                  | \r\n| **void ensureCapacity(int minCapacity)** | Stringbuilder'ın kapasitesinin en az minCapacity kadar  | \r\n|                                          | olmasını sağlar                                         | \r\n\r\n* StringBuilder sınıfı **setLength(int newLength)** ile karakter dizisinin uzunluğunu ayarlarken  newlength değeri kendi uzunluğundan büyük olursa dizinin sonuna eksik kadar null değeri ekler.Eğer newlength  değeri kendi uzunluğundan kısaysa da dizinin sonundan gerekilen kadar karakteri siler.\r\n~~~~java\r\npackage ucankucuk.github.io;\r\n\r\npublic class SetLengthMetodExample {\r\n    public static void main(String[] args) {\r\n        StringBuilder sb = new StringBuilder(); // 16 kapasiteli StringBuilder nesnesi oluşturuldu.\r\n        System.out.println(\"Boş StringBuilder nesnesini kapasitesi = \" + sb.capacity());\r\n        System.out.println(\"Boş StringBuilder nesnesinin uzunluğu = \" + sb.length());\r\n        sb.append(\"0123456789ABCDEF\");\r\n        System.out.println(\"Eklenen = 0123456789ABCDEF\" + \" Eklemeden sonra uzunluk = \" + sb.length());\r\n        sb.append(\"UTKU\");\r\n        System.out.println(\"StringBuilder nesnesini içeriği = \" + sb);\r\n        System.out.println(\"Son eklemeden sonra uzunluk = \" + sb.length());\r\n        System.out.println(\"Son eklemeden sonra kapasite = \" + sb.capacity());\r\n\r\n        /*\r\n         * 16 kapasitesindeki sb nesnesine 4 karakter daha eklediğimizde hata vermedi.\r\n         * Çünkü StringBuilder otomatik olarak kapsiteyi arttırdı.\r\n         */\r\n    }\r\n\r\n}\r\n~~~~\r\n\r\n* **Ekran Çıktısı**:\r\n - Boş StringBuilder nesnesini kapasitesi = 16\r\n - Boş StringBuilder nesnesinin uzunluğu = 0\r\n - Eklenen = 0123456789ABCDEF Eklemeden sonra uzunluk = 16\r\n - StringBuilder nesnesini içeriği = 0123456789ABCDEFUTKU\r\n - Son eklemeden sonra uzunluk = 20\r\n - Son eklemeden sonra kapasite =34 \r\n\r\n* Ayrıca **append(), insert(), setLength()** metodları çağırıldığından kapasite otomatik olarak büyür.\r\n\r\n~~~~java\r\npackage ucankucuk.github.io;\r\n\r\npublic class IncreasedAutomatically {\r\n    public static void main(String[] args) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"0123456789ABCDEF\");\r\n        System.out.println(\"StringBuilding uzunluğu = \" + sb.length() + \" StringBuilder kapasitesi = \" + sb.capacity());\r\n        sb.append(\"UTKU\");\r\n        sb.setLength(5);\r\n        System.out\r\n                .println(\"Değişiklikten sonraki StringBuilder nesnesi = \" + sb + \"\\n\" + \"Değişiklikten sonraki kapasite = \" + sb.capacity() + \"\\n\" + \"Değişiklikten sonraki uzunluk = \" + sb.length());\r\n        /* insert() metodu ile belirlenen yere ekleme yapabiliriz. */\r\n        sb.insert(5, \"5\");\r\n        System.out.println(\"Eklemeden sonra StringBuilder nesnesi = \" + sb + \"\\n\" + \"Eklemeden sonraki kapasite = \" + sb.capacity() + \"\\n\" + \"Eklemeden sonraki uzunluk = \" + sb.length());\r\n    }\r\n}\r\n~~~~\r\n\r\n* Aşağıda `StringBuilder` sınıfının metodları yer almaktadır.\r\n\r\n![ucankucuk.github.io](https://lh5.googleusercontent.com/_xRlML9Wz_ZvkDSqqWr_0u_CPPJa-_1hMRRCOs8U457Sp8kLovNSbADWmGYXf6cE97r_Eo-PZTEMaKCRwUb6NmZn-XNUNfLYRd5hdoSX8-FiYedrfNc \"ucankucuk.github.io\")\r\n\r\n\r\n\r\n",
  "google": "UTKU CAN KÜÇÜK utku can küçük github blog java java core spring hibernate jsp servlet connection",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}
